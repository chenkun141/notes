## 数据库锁机制 ##
### 基本锁类型 ###
- 全局锁(使用场景是做全库逻辑备份)  
	全局锁是对整个数据库实例加锁.MySQL提供了一个加全局读锁的方法,命令是Flush tables with read lock(FTWRL).当你需要让整个库处于只读状态的时候,可以使用这个命令,之后其他线程的一下语句会被阻塞:数据更新语句(数据的增删改),数据定义语句(包括建表,修改表结构等)和更新类事务的提交语句.
- 行级锁是一种排他锁,防止其他事务修改此行;
	1. 在使用以下语句时,Oracle会自动应用行级锁: insert,update,delete,select...for update[of columns][wait n|nowait];
	2. select...for update语句允许用户一次锁定多条记录进行更新
	3. 使用commit或rollback语句释放锁  
-  表级锁分为5类:
	1. 行共享(row share)-禁止排他锁定表
	2. 行排他(row exclusive)-禁止使用排他锁和共享锁
	3. 共享锁(share)-锁定表,对记录只读不写,多个用户可以同时在同一个表上应用此锁
	4. 共享行排他(share row exclusive)-比共享锁更多的限制,禁止使用共享锁级更高的锁
	5. 排他(exclusive)-限制最强的表锁,仅允许其他用户查询该表的行.禁止修改和锁定表

## MySQL表级锁与行级锁 ##
### 表级锁 ###
MySQL表级锁分为读锁和写锁。

- 读锁
用法：LOCK TABLE table_name [ AS alias_name ] READ

释放锁使用UNLOCK tables.可以为表使用别名，如果一旦使用别名在使用的时候也必须采用别名。成功申请读锁的前提是当前没有线程对该表使用写锁，否则该语句会被阻塞。申请读锁成功后，其他线程也可以对该表进行读操作，但不允许有线程对其进行写操作，就算是当前线程也不允许。当锁住了A表之后，就只能对A表进行读操作，对其他表进行读操作会出现错误（tablename was not locked with LOCK TABLES）

- 写锁
用法： LOCK TABLE table_name [AS alias_name] [ LOW_PRIORITY ] WRITE

同样也可以使用别名，与读锁不同的是，写锁中可以指定锁的优先级。LOW_PRIORITY是一种比读锁更低优先级的锁,当多个线程同时申请多种锁（LOW_PRIORITY,READ,WRITE）时，LOW_PRIORITY的优先级最低。读锁申请成功的前提是没有线程对表加读锁和其他写锁，否则会被阻塞。

表级锁在MyISAM和innoDB中都有用到，创建锁的开销小，不会出现死锁，由于锁定的是整张表，所以并发度低。当需要频繁对大部分数据做 GROUP BY 操作或者需要频繁扫描整个表时，推荐使用表级锁。

### 行级锁 ###
行级锁是Mysql中锁定粒度最细的一种锁，能大大减少数据库操作的冲突，由于其粒度小，加锁的开销最大。行级锁分为共享锁和排他锁。
#### 共享锁(S LOCK) ####
- 用法： SELECT ... LOCK IN SHARE MODE;  
    MySQL会对查询结果集中每行都添加共享锁。
- 锁申请前提：当前没有线程对该结果集中的任何行使用排他锁，否则申请会阻塞。
- 操作限制：使用共享锁线程与不使用共享锁线程对锁定记录操作限制表


|线程	|		读取操作	|写入操作			|共享锁申请	|排他锁申请|
| :-- | :-- | :-- | :-- | :-- |
|使用共享锁 |	可读 | 可写/不可写（报错） |	可申请	|	可申请 |
|不使用共享锁	 | 可读	|	不可写（阻塞）	|	可申请	|	不可申请（阻塞）|


1. 使用共享锁线程可对其锁定记录进行读取，其他线程同样也可对锁定记录进行读取操作，并且这两个线程读取的数据都属于同一个版本。

2. 对于写入操作，使用共享锁的线程需要分情况讨论，当只有当前线程对指定记录使用共享锁时，线程是可对该记录进行写入操作（包括更新与删除），这是由于在写入操作前，线程向该记录申请了排他锁，然后才进行写入操作；当其他线程也对该记录使用共享锁时，则不可进行写入操作，系统会有报错提示。不对锁定记录使用共享锁的线程，当然是不可进行写入操作了，写入操作会阻塞。

3. 使用共享锁进程可再次对锁定记录申请共享锁，系统并不报错，但是操作本身并没有太大意义。其他线程同样也可以对锁定记录申请共享锁。

4. 使用共享锁进程可对其锁定记录申请排他锁；而其他进程是不可以对锁定记录申请排他锁，申请会阻塞。  

#### 排他锁(X LOCK) ####
- 用法： SELECT ... FOR UPDATE;  
   MySQL会对查询结果集中每行都添加排他锁，在事物操作中，任何对记录的更新与删除操作会自动加上排他锁。
- 锁申请前提：当前没有线程对该结果集中的任何行使用排他锁或共享锁，否则申请会阻塞。
- 操作限制：使用排他锁线程与不使用排他锁线程对锁定记录操作限制表

|线程			|读取操作           |写入操作	|共享锁申请	|排他锁申请|
| :-- | :-- | :-- | :-- | :-- |
| 使用排他锁 |	可读（新版本）		|可写		|		可申请	|	可申请  |
| 不使用排他锁 |	可读（旧版本）|	不可写(阻塞)	 | 不可申请(阻塞)	| 不可申请(阻塞)  |

1. 使用排他锁线程可以对其锁定记录进行读取，读取的内容为当前事物的最新版本；而对于不使用排他锁的线程，同样是可以进行读取操作，这种特性是一致性非锁定读。即对于同一条记录，数据库记录多个版本，在事物内的更新操作会反映到新版本中，而旧版本会提供给其他线程进行读取操作。

2. 使用排他锁线程可对其锁定记录进行写入操作；对于不使用排他锁的线程，对锁定记录的写操作是不允许的，请求会阻塞。

3. 使用排他锁进程可对其锁定记录申请共享锁，但是申请共享锁之后，线程并不会释放原先的排他锁，因此该记录对外表现出排他锁的性质；其他线程是不可对已锁定记录申请共享锁，请求会阻塞。

4. 使用排他锁进程可对其锁定记录申请排他锁（实际上并没有任何意义）；而其他进程是不可对锁定记录申请排他锁，申请会阻塞。

### 乐观锁和悲观锁 ###
- **悲观锁:** 就是基于数据库机制实现的,比如在使用select子句的时候加上for update,那么直到改子句的事务结束为止,任何应用都无法修改select出来的记录

- **乐观锁:** 是基于应用的版本机制来实现的,一般会在表里面谁一个版本字段.一般的update场景是这样:  

		1 select a,v from tb where id =1 ;
		//假设得到的数据是:['xxxx',11111]
	
		2 update tb set a='yyyy',v=systimestamp where v=111111;
		//注意,v一般不会再业务操作的时候修改
		//这要求每一次update操作都变更版本字段,否则还是要进程间的数据,还是会被相互覆盖

## 执行计划explain ##
使用explain只需要在原有select基础上加上explain关键字就可以了。如下：

	mysql> explain select * from servers;
	+----+-------------+---------+------+---------------+------+---------+------+------+-------+
	| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows | Extra |
	+----+-------------+---------+------+---------------+------+---------+------+------+-------+
	|  1 | SIMPLE      | servers | ALL  | NULL          | NULL | NULL    | NULL |    1 | NULL  |
	+----+-------------+---------+------+---------------+------+---------+------+------+-------+
	1 row in set (0.03 sec)

explain各字段的含义

1. id：表示sql执行的顺序的标识，sql从大到小的执行
2. select_type: 表示查询中每个select子句的类型
3. table： 显示这一行的数据是关于哪张表的，有时不是真实的表名字
4. type： 表示mysql在变种找到所需行的方式，又称“访问类型”，常用的类型有：ALL,index，range,ref,eq_ref,const,system,NULL(**从左到右，性能从差到好**)
5. possible_keys：指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用
6. Key：key列显示MySQL实际决定使用的键（索引），如果没有选择索引，键是NULL。
7. key\_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度(key\_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）
8. ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
9. rows： 表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数，理论上行数越少，查询性能越好
10. Extra：该列包含MySQL解决查询的详细信息

## 事务隔离 ##
提到事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中I，也就是“隔离性”.  
当数据库上有多个事务同时执行的时候,就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。  
在谈隔离级别之前,你首先要知道,你隔离得越严实,效率就会越低.因此很多时候,我们都要在二者之间寻找一个平衡点.sql标准的事务隔离级别包括:读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）.下面我逐一为你解释:  
- 读未提交是指,一个事务还没提交时,它做的变更就能被别的事务看到
- 读提交是指,一个事务提交之后,它做的变更才会被其他事务看到.
- 可重复读是指,一个事务执行过程中看到的数据,总是跟这个是我在启动是看到的数据是一致的.当然在可重复读隔离级别下,未提交变更对其他事务也是不可见的.
- 串行化,顾名思义是对于同一行记录,"写"会加"写锁","读"会加"读锁".当出现读写锁冲突的时候,后访问的事务必须等前一个事务执行完成,才能继续执行.  

## 30种mysql优化查询方法 ##
1. 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。  
2. 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。  
3. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：  
	`select id from t where num is null`  
	可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：   
	`select id from t where num=0`  
4. 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，  
		如：
	    
		select id from t where num=10 or num=20
	
	　　可以这样查询：
		
		select id from t where num=10
		union all
		select id from t where num=20  
	
5. 下面的查询也将导致全表扫描：  
　　`select id from t where name like '%abc%'`  
　　若要提高效率，可以考虑全文检索。  
6. in 和 not in 也要慎用，否则会导致全表扫描，如：  
　　`select id from t where num in(1,2,3)`  
　　对于连续的数值，能用 between 就不要用 in 了：  
　　`select id from t where num between 1 and 3`    
7. 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时;它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：  
　　`select id from t where num=@num`  
　　可以改为强制查询使用索引：  
　　`select id from t with(index(索引名)) where num=@num`    
8. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：
　　`select id from t where num/2=100`  
　　应改为:   
　　`select id from t where num=100*2`    
9. 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：
　　    `select id from t where substring(name,1,3)='abc'--name以abc开头的id`
    　　`select id from t where datediff(day,createdate,'2005-11-30')=0--'2005-11-30'生成的id`  
　　应改为:  
　　    `select id from t where name like 'abc%'`  
    　　`select id from t where createdate>='2005-11-30' and createdate<'2005-12-1'`  
10. 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
11. 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。
12. 不要写一些没有意义的查询，如需要生成一个空表结构：
　　`select col1,col2 into #t from t where 1=0`
　　这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：
　　`create table #t(...)`

13. exists 和 in 效率问题：  
	1. 如果查询的两个表大小相当，那么用in和exists差别不大。
	2. 如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in：  
    
	例如：表A（小表），表B（大表）  
	1：  
	select * from A where cc in (select cc from B) 效率低，用到了A表上cc列的索引；  
	select * from A where exists(select cc from B where cc=A.cc) 效率高，用到了B表上cc列的索引。  
	相反的  
	2：  
	select * from B where cc in (select cc from A) 效率高，用到了B表上cc列的索引；  
	select * from B where exists(select cc from A where cc=B.cc) 效率低，用到了A表上cc列的索引。  
	
14. 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。  
15. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。  
16. 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。  
17. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。  
18. 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。  
19. 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。  
20. 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限(只有主键索引)。  
21. 避免频繁创建和删除临时表，以减少系统表资源的消耗。  
22. 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。  
23. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度;如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。  
24. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。  
25. 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。  
26. 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。  
27. 与临时表一样，游标并不是不可使用。对小型数据集使用FAST_FORWARD游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。  
28. 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。  
29. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。  
30. 尽量避免大事务操作，提高系统并发能力。


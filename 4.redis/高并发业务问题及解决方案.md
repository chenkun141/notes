## 缓存常见问题 ##
### 1.缓存穿透 ###
缓存穿透指的是使用**不存在的key进行大量的高并发查询**，这导致缓存无法命中，每次请求都要穿透到后端数据库系统进行查询，数据库压力过大。

解决方案 
 
- 常用解决方案：将空值缓存起来。
- 其他解决方案：使用布隆过滤器（guava 19开始已支持布隆过滤器） 备注：如果你可以理解太白老师讲的基于redis位图自己实现的布隆过滤器，可以说说，更加分

### 2.缓存击穿 ###
缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力  

解决方案：

- 1.互斥锁  如果项目不会多部署则可以使用jvm锁，如果会多部署则使用分布式锁


### 3.缓存雪崩 ###
缓存雪崩指缓存服务器重启或者大量缓存集中在某一个时间段内失效

解决方案：

- 1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据
和写缓存，其他线程等待
- 2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置
为长期
- 3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀
- 4：如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中

### 4.数据库缓存一致性 ###
1.双写不一致  
2.读写不一致

解决方案:  

- 1. 对于并发几率很小的数据(如个人维度的订单数据,用户数据等),这种几乎不用考虑这个问题,很少会发生缓存不一致,可以给缓存数据加上过期时间,每隔一段时间出发读的主动更新即可.
- 2.就算并发很高,如果业务上能容忍短时间的缓存数据不一致(如商品名称,商品分类菜单等),缓存加上过期时间依然可以解决大部分业务对于缓存的要求.
- 3. 如果不能容忍缓存数据不一致,可以通过加读写锁保证并发读写或写写的时候按顺序排好队,读读的时候相当于无锁.
- 4.也可以用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存,但是引入了新的中间件,增加了系统的复杂度.

**总结:** 
以上我们针对的都是读多写少的情况加入缓存提高性能,如果写多读多的情况又不能容忍缓存数据 不一致,那就没必要加缓存了,可以直接操作数据库.放入缓存的数据应该是对实时性,一致性要求不是很高的数据.切记不要为了用缓存,同事又要保证绝对的一致性做大量的过度设计和控制,增加系统复杂度!

### 5.热点缓存key重建优化 ###
1.当前key是一个热点key(例如一个热门的娱乐新闻),并发量非常大  
2.重建缓存不能在短时间完成,可能是一个复杂计算,例如复杂的SQL,多次IO,多个依赖等
在缓存失效的瞬间,有大量线程来重建缓存,造成后端负载加大,甚至可能会让应用崩溃.

解决方案:

- 利用互斥锁(分布式锁)来解决,此方法只允许一个线程重建缓存,其他线程等待重建缓存的线程执行完,重新从缓存获取数据即可.



# Redis持久化 #
## RDB ##
1. save
save 60 1000 //关闭RDB只需要将所有的save保存策略注释掉即可
 60秒内有至少有1000个键被改动,自动保存一次

2. bgsave
Redis 借助操作系统提供的写时复制技术（Copy-On-Write, COW），在生成快照的同时，依然可以正常
处理写命令。简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。
bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些
数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，那
么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文
件，而在这个过程中，主线程仍然可以直接修改原来的数据。

默认使用bgsave方式

## AOF ##
保存最近写入,且仍未保存到快照中的那些数据,将修改的每一条指令记录进文件appendonly.aof中

### AOF重写 ###
执行bgrewriteaod重写AOf,AOF重写redis会fork出一个子进程去做(与bgsave命令类似),不会对redis正常命令处理有太多影响

## Redis 4.0 混合持久化 ##
开启 aof-use-rdb-preamble yes 
如果开启了混合持久化，AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将
重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改内存数据的命令存在一
起，都写入新的AOF文件，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改
名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。
于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志就可以完全替代之前的
AOF 全量文件重放，因此重启效率大幅得到提升。

# Redis架构 #
## 主从工作原理 ##
如果你为master配置了一个slave，不管这个slave是否是第一次连接上Master，它都会发送一个PSYNC命令给master请求复制数据。
master收到PSYNC命令后，会在后台进行数据持久化通过bgsave生成最新的rdb快照文件，持久化期
间，master会继续接收客户端的请求，它会把这些可能修改数据集的请求缓存在内存中。当持久化进行完
毕以后，master会把这份rdb文件数据集发送给slave，slave会把接收到的数据进行持久化生成rdb，然后
再加载到内存中。然后，master再将之前缓存在内存中的命令发送给slave
1. 全量复制
2. 部分复制,断点续传
## 哨兵模式 ##

## 集群模式 ##
Redis Cluster将所有数据划分为16384个slots(槽位),每个节点负责其中一部分槽位.槽位的信息存储于每个节点中.  
当Redis Cluster的客户端来连接集群时,它也会得到一份集群的槽位配置信息并将其缓存在客户端本地.这样当客户端要查找某个key时,可以直接定位到目标节点.同时因为槽位的信息可能会存在客户端与服务器不一致的情况,还需要纠正机制来实现槽位信息的校验调整.

## 槽位定位算法 ##
Cluster默认会对key值使用crc16算法进行hash得到一个整数值,然后用这个整数值对16384进行取模来得到具体槽位.
HASH_SLOT=CRC16(key) mod 16384

## 跳转重定位 ##
当客户端向一个错误节点发出了指令,该节点会发现指令的key所在槽位并不归自己管理,这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址,告诉客户端去连这个节点去获取数据.客户端收到指令后除了跳转到正确的节点上去操作,还会同步更新纠正本地的槽位映射表缓存,后续所有key将使用新的槽位映射表.

## Redis集群选举原理分析 ##
当slave发现自己的master变为FAIL状态时,便尝试进行Failover,切成为新的master.由于挂掉的master可能会有多个slave,从而存在多个slave竞争成为master节点的过程,其过程如下:
1. slave发现自己的master变为FAIL
2. 将自己记录的集群current Epoch加1,并广播FAILOVER_AUTH_REQUEST信息
3. 其他节点收到该信息,只有master响应,判断请求者的合法性,并发送FAILOVER_AUTH_ACK,对每一个epoch只发送一次ack
4. 尝试failover的slave收集master返回的failover_auth_ack
5. slave收到超过半数master的ack后变成新master(这里解释了集群为什么至少需要三个主节点,如果只有两个,当其中 一个挂了,只剩一个主节点是不能选举成功的)
6. slave广播Pong消息通知其他集群节点

# Redis对于过期key的清除策略 #
